\section{Cadre d'expérimentation}\label{sec:valid:perfs:cadre}
L'ensemble de la distribution Astronef-Asteroid est sous forme de \textit{bundles Java-OSGi}. Ainsi, ces prototypes peuvent être déployés sur toute plateforme possédant la technologie \textit{Java}. De plus, l'environnement \textit{OSGi} nous permet d'exploiter un environnement modulaire basé sur les architectures à service. La plateforme \textit{OSGi} doit embarquer le \textit{bundle} \textit{iPojo} (\url{http://felix.apache.org/site/apache-felix-ipojo.html}) pour pouvoir utiliser l'architecture à composants orientés service. Nous utilisons dans nos expériences la plateforme \textit{OSGi} \textit{Apache Felix} en version 3.0.2.

La distribution Astronef est fournie en trois \textit{bundles} obligatoires à déployer pour pouvoir utiliser l'ensemble des fonctionnalités présentés dans cette thèse (api core parser). Ces \textit{bundles} embarquent aussi le moteur \textit{Prova} (\url{http://prova.ws}, version 3.1.9 minimale) capable d'évaluer l'ensemble des règles présentées. Les extensions à Astronef sont aussi sous forme de \textit{bundles} dont les classes dépendent de l'\textit{api}. Astronef est disponible sous licence Apache 2.0 à l'adresse \url{http://astral.googlecode.com}.

Asteroid est une extension d'Astronef distribuée en un seul \textit{bundle}. Il embarque le SGBD \textit{H2} (\url{http://h2database.com}). Ce SGBD est entièrement en \textit{Java} ce qui permet une uniformité en terme de technologies. Le binaire ou le code source d'Asteroid n'est actuellement pas disponible au public.

L'ordinateur utilisé pour les expérimentations possède un processeur \textit{Intel Xeon}, quadricœur de fréquences 2.8Ghz. Il possède 6Go de mémoire vive et un disque dur d'une vitesse de 7200RPM. Le système d'exploitation installé est Linux Ubuntu 11.04. La plupart des expérimentations se sont faites dans un environnement clôt en isolant les processus sur trois cœurs dédiés afin d'éviter les interférences. Enfin, les expérimentations ont été faites dans des conditions les plus stables possible, après que le \textit{JIT} soit passé, après initialisation des caches internes et avec un \textit{garbage collector} (\textit{GC}) le plus stable possible.

Les performances sont mesurées par la latence d'un n-uplet. La latence est mesurée par la différence de timestamp système entre la source et le puits de la requête. Elle permet d'indiquer le temps total nécessaire au traitement d'un n-uplet. Le coût mémoire n'est pas compté, mais comme les trop grands coûts impactent le temps de traitement, notamment en \textit{Java} avec le \textit{GC}, nous supposons que cette métrique est représentative.