\section{Intégration de supports persistants}
Les supports persistants sont dirigés par le paradigme de l'interrogation instantanné. Bien que les gestionnaires de bases de données et de flux de données partagent les mêmes fondations théoriques. Le problème réside dans la difficulté à combiner les deux paradigmes : requêtes continues sur des flux continus et requêtes instantannées sur une base de donnée. Dans cette section, nous analyserons le problème des requêtes hybrides mélangeant flux et données persistantes. D'autres utilisations des supports de persistances existent comme par exemple : la matérialisation des mémoires tampons~\cite{Abadi:aurora}. Cette application n'est toutefois qu'un point particulier de mise en œuvre.

\subsection{Requêtes dépendantes à un contexte}
Nous avons déjà vu les requêtes par désignation dans la section~\ref{sec:rw:sgfd:infra:designation}. La requête sous-jacente utilisée pour désigner les sources d'informations est posée sur un ensemble de donnée de manière instantanné. Nous retrouvons donc un cadre similaire. L'ensemble des données pouvant être interrogé par cette requête est assimilable à un contexte tel que présenté en section~\ref{sec:rw:supervision:context}.

L'utilisation d'un catalogue de meta-données en tant que contexte est souvent utilisé dans les applications de supervisions à base de flux. Cette utilisation a été pratiqué dans les projets SStreamWare et plus récemment sur SmartCIS~\cite{Liu:smartcis}. Dans ce dernier, un SGBD relationnel est utilisé pour recenser les différents dispositifs logiques et physiques. Au moment du déploiement de la requête, l'optimiseur interroge cette base de donnée pour sélectionner les sources. D'un point de vue modélisation, les méta-données sont considérés comme des attributs spéciaux des flux. Lors de la réécriture de la requête, les attributs de méta-données sont écartés pour effectuer l'interrogation sur le catalogue. Il est intéressant de noter que la dynamique des meta-données est typiquement \textit{stable} ou \textit{statique}.

Toutefois, le contexte peut être mis à jour. L'impact d'une telle mise à jour influera sur l'évaluation de la requête. Par exemple, si l'utilisateur déploie la requête précédemment citée : \enquote{Flux des températures du batiment A} et qu'un nouveau capteur arrive dans le batiment. Doit-il être pris en considération ? Cette idée ouvre la voie au concept de transaction dans le cadre des requêtes continues. Le phénomène a d'abord été cerné et répondu par le protocole de mise à jour de SStreamWare~\cite{Gurgen:transaction}. Si une mise à jour est effectuée, le protocole ira modifier les nœuds et les requêtes concernés pour changer le déploiement si nécessaire.

De façon proche, l'idée de transaction pour les requêtes continues a ensuite été présenté dans~\cite{Botan:transaction}. Les transactions sont définies comme un ensemble restreints d'opérations de lectures ou d'écritures appliquées sur les flux ou relations avec un ordre d'exécution défini. De cette façon, l'exécution de requête continues est un ensemble de micro-transactions, garantissant une exécution sans conflit. Il est notable que cette conception permet de réutiliser les transactions des gestions bases de données.

D'un point de vue opérationnel, la sélection sur méta-données consiste en une semi-jointure (sur les identifiants typiquement) avec le résultats d'une jointure sur un support persistant. Ainsi, soit le système applique une désignation comme vu précédemment, et ouvre la possibilité à des problèmes de sémantiques devant être gérés par des protocoles de mises à jours. Soit, le système applique l'opération de semi-jointure avec le support persistant qui a une vue à jour des données.

\subsection{Analyses sur historique}
La deuxième utilisation majeure des supports persistants est le fait d'accoler à un flux des données d'analyses faites sur des historiques d'autres flux. Par exemple :
\begin{center}
\it Flux des charges processeurs des différents équipements domestiques dont la charge actuelle est anormale.
\end{center}
Dans ce cas, il est nécessaire de calculer la moyenne historique à tout moment pour augmenter le flux de ces informations. L'implémentation d'une telle procédure doit considérer le fait que les données persistés sont constamment mises à jour et que l'opération d'agrégation soit coûteuse. 

La première mise en œuvre d'une telle opération a été faite dans les travaux joints de FastBit et TelegraphCQ~\cite{Reiss:fastbit}. Pour cela, deux requêtes sont spécifiés : celle exécutée sur les flux de données et celle exécutée sur une base de donnée. Puis, un \textit{controlleur} exécutera les deux requêtes dans le but d'ajouter les données calculées sur la base de données au n-uplets des flux.

Par la suite, une opération plus explicite a été définie dans \textit{Moirae}~\cite{Balazinska:moirae} : l'opérateur \textit{Rappel} (\textit{Recall}). Pour un identifiant en particulier, l'opérateur regroupe les agrégats d'un historique $H$. Afin d'absorber la charge, la gestion des \textit{opérations de rappel} peut être distribuée. Enfin, l'utilisation de contextes quelconques matérialisés est aussi utilisé dans ce projet.

Il est intéressant de noter que ces requêtes peuvent être assimilés comme des désignations sur des données de contextes consolidées par des analyses historiques.

\subsection{Une première approche intégrée}
Enfin, une approche unifiée a été présentée par Oracle~\cite{Witkowski:oraclecq}. Cette extension du SGBD relationnel permet de manipuler les requêtes continues. Ainsi, dans le même système se retrouvent : flux, relations et historiques. Toutefois, le système manque d'un modèle commun pour formaliser les intégrations entre les deux paradigmes comme nous l'avons présenté précédemment. En effet, l'utilisateur doit décrire comment les vues matérialisées\footnote{Les vues matérialisés servent de passerelles comme dans \textit{Chronicle}} doivent être créés et mises à jours. 

Un point novateur étant que le système explicite clairement différentes sémantiques de mises à jour de la vue des données persistantes utilisée par la requête continue. L'approche reste toutefois dirigée par les mécanismes et l'implémentation. L'infrastructure résultante est toutefois capable d'exécuter les requêtes présentes dans cette section.

\subsection{Synthèse}
Dans cette section, nous avons présenté l'intégration de supports de persistants au monde des flux de données. Quelques approches ad-hoc ont donc été développés. Il est souvent considéré dans l'état de l'art qu'il est naturellement possible de joindre des relations persistantes. Il reste toutefois un manque de formalisation concernant la gestion des mises à jours. Une unification des modèles permettrait de pouvoir effectuer une requête claire et sans ambiguïté sur son fonctionnement futur.
