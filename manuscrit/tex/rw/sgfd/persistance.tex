\section{Intégration de supports persistants}
Les supports persistants sont dirigés par le paradigme de l'interrogation instantanné. Bien que les gestionnaires de bases de données et de flux de données partagent les mêmes fondations théoriques. Le problème réside dans la difficulté à combiner les deux paradigmes : requêtes continues sur des flux continus et requêtes instantannées sur une base de donnée.

\subsection{Requêtes dépendantes à un contexte}
Nous avons déjà vu les requêtes par désignation dans la section~\ref{sec:rw:sgfd:infra:designation}. La requête sous-jacente utilisée pour désigner les sources d'informations est posée sur un ensemble de donnée de manière instantanné. Nous retrouvons donc un cadre similaire. L'ensemble des données pouvant être interrogé par cette requête est assimilable à un contexte tel que présenté en section~\ref{sec:rw:supervision:context}.

L'utilisation d'un catalogue de meta-données en tant que contexte est souvent utilisé dans les applications de supervisions à base de flux. Cette utilisation a été pratiqué dans les projets SStreamWare et plus récemment sur SmartCIS~\cite{Liu:smartcis}. Dans ce dernier, un SGBD relationnel est utilisé pour recenser les différents dispositifs logiques et physiques. Au moment du déploiement de la requête, l'optimiseur interroge cette base de donnée pour sélectionner les sources. D'un point de vue modélisation, les méta-données sont considérés comme des attributs spéciaux des flux. Lors de la réécriture de la requête, les attributs de méta-données sont écartés pour effectuer l'interrogation sur le catalogue. Il est intéressant de noter que la dynamique des meta-données est typiquement \textit{stable} ou \textit{statique}.

Toutefois, le contexte peut être mis à jour. L'impact d'une telle mise à jour influera sur l'évaluation de la requête. Par exemple, si l'utilisateur déploie la requête précédemment citée : \enquote{Flux des températures du batiment A} et qu'un nouveau capteur arrive dans le batiment. Doit-il être pris en considération ? Cette idée ouvre la voie au concept de transaction dans le cadre des requêtes continues. Le phénomène a d'abord été cerné et répondu par le protocole de mise à jour de SStreamWare~\cite{Gurgen:transaction}. Si une mise à jour est effectuée, le protocole ira modifier les nœuds et les requêtes concernés pour changer le déploiement si nécessaire.

De façon proche, l'idée de transaction pour les requêtes continues a ensuite été présenté dans~\cite{Botan:transaction}. Les transactions sont définies comme un ensemble restreints d'opérations de lectures ou d'écritures appliquées sur les flux ou relations avec un ordre d'exécution défini. De cette façon, l'exécution de requête continues est un ensemble de micro-transactions, garantissant une exécution sans conflit. Il est notable que cette conception permet de réutiliser les transactions des gestions bases de données.

D'un point de vue opérationnel, la sélection sur méta-données consiste en une semi-jointure (sur les identifiants typiquement) avec le résultats d'une jointure sur un support persistant. Ainsi, soit le système applique une désignation comme vu précédemment, et ouvre la possibilité à des problèmes de sémantiques devant être gérés par des protocoles de mises à jours. Soit, le système applique l'opération de semi-jointure avec le support persistant qui a une vue à jour des données.

\subsection{Analyses sur historique}
%La deuxième utilisation majeure des supports persistants est le fait de 

%The second main usage is gathering logged data from the past of a stream as seen in query Q\ref{query:historicsensor}. The implementation must consider the fact that logged data are constantly augmented and that the aggregate operation may be costly. The first proposal tackles such query is the joint work between FastBit and TelegraphCQ~\cite{Reiss:fastbit}. Two queries were specified from the data stream point of view, and from the log storage point of view. Then, a controller would execute the two queries in order to add data from the logged query for each tuples on the stream.
%
%Later on, a more explicit operator has been defined in Moirae~\cite{Balazinska:moirae}: the operator \textit{Recall}. For a specific identifier, \textit{Recall} gathers aggregates from the history $H$. To absorb the charge, the management of \textit{recall operations} can be distributed. \textit{Materialized contexts} are used to perform semi-joins as seen previously. This allows past data of a stream to be used as meta-data describing this stream.
\subsection{Une première approche intégrée}

%In this section we will see how related works used persistent data along with a data stream management system in order to enhance their monitoring capabilities. 
%Three main ways to deal with queries like Q\ref{query:designation} Q\ref{query:historicsensor} can be identified: the use of catalogs, the use of stream dump and the use of streams inside a DBMS.
%
%\textbf{Using a catalog}: 
%The first main usage consist in appending meta-data from a catalog to the stream e.g. to evaluate Q\ref{query:designation}. A straight-forward solution would be to make the stream source (i.e. sensors in Q\ref{query:designation}) generate all associated meta-data. A more efficient way is to have a \textit{persistent} catalog in order to know if a specific source matches meta-data (e.g. type temperature and inside building \textbf{A}). This usage has been chosen on (X)SStreamWare~\cite{Gurgen:sstreamwarepaper} and more recently on SmartCIS~\cite{Liu:smartcis}. In those projects, the main stream contains specific attributes (called \textit{properties}). If one of them is used in a selection of projection, it is specifically queried from a device catalog potentially spread around the distributed architecture.
%
%However, as shown in~\cite{Gurgen:update}, the impact of changes in the meta-data may affect the query evaluation and semantic. For instance, if a new sensor enters into the building, must its stream be included in the query or not? Such choices are currently mainly dependent on the implementation and are not specified  at the query language level.
%
%From an operational point of view, selecting on meta-data consists of a semi-join (on the identifiers typically) with the result of a query on a persistent support. This allows to select the right sources of data early on (temperature sensors, \textit{and} inside the building A). Two types of implementation have been made for two kinds of architectures. Distributed architectures and sources on different nodes, this selection on meta-data is made during the deployment of the query plan as in GSN~\cite{Aberer:gsn} and HiFi~\cite{Franklin:hifi}. This execution is optimal as it does not call the ignored sources, but if there is any changes on the catalog, the query results will not be updated unless the plan is reconstructed explicitly. The second implementation gathers the data until an operator which will perform the semi-join on an up-to-date view of the persistent data. This approach can be used on centralized DSMS or with shared queries. This is not optimal from a communication point of view but a fresh and consistent view of the meta-data is provided at any time.
%
%\textbf{Performing aggregate of stream dump}: 
%The second main usage is gathering logged data from the past of a stream as seen in query Q\ref{query:historicsensor}. The implementation must consider the fact that logged data are constantly augmented and that the aggregate operation may be costly. The first proposal tackles such query is the joint work between FastBit and TelegraphCQ~\cite{Reiss:fastbit}. Two queries were specified from the data stream point of view, and from the log storage point of view. Then, a controller would execute the two queries in order to add data from the logged query for each tuples on the stream.
%
%Later on, a more explicit operator has been defined in Moirae~\cite{Balazinska:moirae}: the operator \textit{Recall}. For a specific identifier, \textit{Recall} gathers aggregates from the history $H$. To absorb the charge, the management of \textit{recall operations} can be distributed. \textit{Materialized contexts} are used to perform semi-joins as seen previously. This allows past data of a stream to be used as meta-data describing this stream.
%
%\textbf{An integrated alternative}: 
%Finally, Oracle has presented in~\cite{Witkowski:oraclecq} a framework to manipulate continuous queries in the Oracle DBMS. Therefore, stream, relations and logs are in the same system and can be manipulated together. However, the system lacks of a common algebra to formalize the integration of the two worlds. The user has to describe how materialized views must be created and updated. To our knowledge~\cite{Witkowski:oraclecq} is the only work that explicitly presents different semantics for updates of data used by continuous queries. The approach is mainly driven by an implementation point of view. The infrastructure is able to execute queries such as Q\ref{query:designation} and Q\ref{query:historicsensor}. On the theoretical side, some proposals~\cite{Patroumpas:window,Jain:spread} have been made to formalize data stream management. But to our knowledge, no project has yet tackled the issues of handling the instantaneous query paradigm inside a continuous query processing system.
%
%Yet, adopted approaches are mainly driven by implementation of ad-hoc solution driven by specific application needs. 
%But integration, in a non specific way, of both streaming and relational world is an important step for many applications such as the one presented in the next section.
