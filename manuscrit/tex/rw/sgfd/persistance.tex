\section{Intégration de supports persistants à la gestion de flux}\label{sec:rw:sgfd:persistance}
Les SGFD utilisent principalement l'interrogation continue, alors que les systèmes de gestions de données persistantes (SGBD par exemple) utilisent l'interrogation instantanée. Bien que les SGBD et SGFD partagent les mêmes fondations théoriques, le problème réside dans la difficulté à combiner les deux types de requêtes. Dans cette section, nous analysons le problème des requêtes hybrides mélangeant flux et données persistantes. D'autres utilisations de supports persistants existent, par exemple la matérialisation des mémoires tampons~\cite{Abadi:aurora}. Cette application n'est toutefois qu'un point particulier d'optimisation de traitement n'altérant pas la sémantique d'interrogation.

\subsection{Requêtes dépendantes à un contexte}
Nous avons déjà vu les requêtes par désignation dans la section~\ref{sec:rw:sgfd:infra:designation}. La requête sous-jacente utilisée pour désigner les sources d'information est posée sur un ensemble de données de manière instantanée. L'ensemble des données pouvant être interrogé par la requête de désignation est assimilable à un contexte tel que présenté en section~\ref{sec:rw:supervision:contexte}.

Les catalogues de meta-données sont souvent utilisés en tant que contexte dans les applications d'observation à base de flux. Ceci a été pratiqué dans les projets SStreamWare et plus récemment sur SmartCIS~\cite{Liu:smartcis}. Dans ce dernier, un SGBD relationnel est utilisé pour recenser les différents dispositifs logiques et physiques. Au moment du déploiement de la requête, l'optimiseur interroge cette base de données pour sélectionner les sources. D'un point de vue de la modélisation, les méta-données sont considérées comme des attributs spéciaux des flux. Lors de la réécriture de la requête, les attributs de méta-données sont identifiés pour effectuer une l'interrogation sur le catalogue. Il est intéressant de noter que ces méta-données ont une évolution lente.

Toutefois, le contexte peut être mis à jour. Une telle mise à jour influe sur l'évaluation de la requête. Par exemple, si l'utilisateur déploie la requête précédemment citée : \enquote{Flux des températures du bâtiment A} et qu'un nouveau capteur arrive dans le bâtiment. Doit-il être pris en considération ? Cette situation ouvre la voie au concept de transaction dans le cadre des requêtes continues. Le phénomène a d'abord été cerné et a été résolu par le protocole de mise à jour de SStreamWare~\cite{Gurgen:transaction}. Si une mise à jour est effectuée, le protocole modifie les nœuds et les requêtes concernées pour changer le déploiement si nécessaire.

De façon proche, l'idée de transaction pour les requêtes continues a ensuite été présentée dans~\cite{Botan:transaction}. Les transactions sont définies comme un ensemble restreint d'opérations de lectures ou d'écritures appliquées sur les flux ou relations avec un ordre d'exécution défini. De cette façon, l'exécution de requête continue est un ensemble de microtransactions, garantissant une exécution sans conflit. Il est notable que cette conception permette de réutiliser les transactions des SGBD.

D'un point de vue opérationnel, la désignation consiste en une semi-jointure (sur les identifiants typiquement) avec le résultat d'une requête sur un support persistant. Ainsi, soit le système applique une procédure de désignation comme vue précédemment, et ouvre la possibilité à des problèmes potentiels de sémantiques. Soit le système applique une opération de semi-jointure avec le support persistant qui a une vue à jour des données. Cependant, cette dernière mise en œuvre nécessite une uniformisation des langages de requêtes entre le support persistant et SGFD.

\subsection{Analyses sur historique}
La deuxième utilisation majeure des supports persistants est l'ajout à un flux des données des analyses faites sur des historiques d'autres flux. Par exemple :
\begin{center}
\it Flux des charges processeurs des différents équipements domestiques dont la charge actuelle est anormale.
\end{center}
Dans ce cas, afin de comparer la charge actuelle à une \textit{charge normale}, il est nécessaire de calculer la moyenne historique à tout moment. L'implémentation d'une telle procédure doit considérer que les données persistantes sont constamment mises à jour et que l'opération d'agrégation soit coûteuse. 

La première mise en œuvre de cette jointure avec agrégat sur l'historique a été faite dans les travaux joints de FastBit et TelegraphCQ~\cite{Reiss:fastbit}. Pour cela, deux requêtes sont spécifiées : celle exécutée sur les flux de données et celle exécutée sur une base de données. Puis, un \textit{contrôleur} exécute les deux requêtes séparément dans le but d'ajouter les données calculées sur la base de données aux n-uplets des flux.

Une opération plus explicite a été définie depuis dans \textit{Moirae}~\cite{Balazinska:moirae} : l'opérateur \textit{Rappel} (\textit{Recall}). Pour un identifiant en particulier, l'opérateur regroupe les agrégats d'un historique $H$. Afin d'absorber la charge, la gestion des \textit{opérations} \textit{de} \textit{rappel} peut être distribuée. Enfin, la matérialisation de contextes plus généralement est aussi utilisée dans ce projet.

Il est intéressant de noter que ces requêtes peuvent être assimilées à des désignations sur des données de contextes consolidées par des analyses historiques.

\subsection{Une première approche intégrée}
Enfin, une approche unifiée a été présentée par Oracle~\cite{Witkowski:oraclecq}. Cette extension du SGBD relationnel permet de manipuler les requêtes continues. Le même système intègre : flux, relations et historiques. Toutefois, le système manque d'un modèle commun pour formaliser les intégrations entre les deux paradigmes comme nous l'avons présenté précédemment. En effet, l'utilisateur doit décrire comment les vues matérialisées\footnote{Les vues matérialisées servent de passerelles comme dans \textit{Chronicle}} doivent être créé et mises à jour. 

Un point novateur est que le système explicite clairement différentes sémantiques de mises à jour de la vue des données persistantes utilisée par la requête continue. L'approche reste toutefois dirigée par les mécanismes et l'implémentation. Néanmoins, l'infrastructure permet d'exécuter les requêtes présentes dans cette section.