\section{Optimisation logique}\label{sec:contrib:astronef:logique}
Cette première application de règles permet de restructurer l'expression de la requête pour avoir la structure la plus adéquate. Dans cette section, nous pourrons exploiter les connaissances accumulés dans les théorèmes d'Astral que nous pourrons retrouver dans le chapitre~\ref{chap:validation:expressivite}.
\subsection{Préparation}
Tout d'abord, il est nécessaire d'appliquer les sucres syntaxiques pouvant être présents dans l'expression. Par exemple, l'opérateur $\ssjoin$ est un opérateur composite qui n'est défini que par la composition d'autres opérateurs primitifs.

\begin{regle}[Sucres syntaxiques]
L'application de sucre syntaxique transformant l'expression $[A1,B1,C1]$ en $[A2,B2,C2]$ se fait par le prédicat :
\begin{center} \textbf{sugar}($[A1,B1,C1]$, $[A2,B2,C2]$).\end{center}
Ce prédicat est appliqué tant qu'il peut l'être (de manière itérative).
\end{regle}

\begin{example}
	Nous nous proposons d'appliquer le sucre syntaxique pour transformer $\Join_c$ en $\sigma_c \Join$. Pour rappel, le prédicat \textit{sugar} sera appliqué si et seulement si ses conditions sont vérifiées. Ici, nous vérifions qu'il y a une condition \textit{Cond} dans les propriétés. Par la suite, nous pouvons transformer la jointure en sélection-jointure (après avoir retiré la condition des propriétés évidemment).
	\begin{lstlisting}
sugar(
	[join,B,C], 
	[sigma, {"condition": Cond}, [
		[join,BOut,C]
	]]
):-
    	map_get(B, "condition", Cond), %La jointure est avec condition
    	!, % alors...
    	map_remove(B, "condition", BOut). %Suppression de la condition
	\end{lstlisting}
\end{example}

Maintenant, afin de pouvoir traiter correctement les différents nœuds, il nous faut inférer les deux propriétés majeures de chaque nœud d'une requête qui va définir la nature de son résultat intermédiaire : son type (\textit{flux} ou \textit{relation}) et ses attributs. Pour cela, il faut être garanti que les sources exposent leurs attributs et types dans leurs propriétés. Par la suite, un programme appliquera ces règles de façon récursive. Les résultats seront stockés dans les propriétés \textit{type} et \textit{attributes}.

\begin{regle}[Inférences de types et d'attributs]
L'inférence du type $Type$ de l'expression $[A,B,C]$ dont les types fils sont $TypesFils=[T1,...]$ se fait par le prédicat :
\begin{center} \textbf{typerules}($[A,B,C,TypesFils]$, $Type$).\end{center}
De façon similaire, nous obtenons pour la liste d'attributs d'un nœud :
\begin{center} \textbf{attribrules}($[A,B,C,AttributsFils]$, $Attributs$).\end{center}
Ceux deux prédicats s'appliquent de manière récursive, d'abord la projection puis la sélection.
\end{regle}


\begin{example}
	Pour la définition de la jointure, les règles sont simples. Le liste des attributs est l'union des listes d'attributs fils. Et le type est du relationnel vers le relationnel.
	\begin{lstlisting}
typerules([join,_,_, TypesFils], Type):- 
	allequal(TypesFils,Type), % Verification que tous soient relationnels 
	relation(Type), !.
attribrules([join,_,_,AttributsFils], Attributs):- !, 
	union(AttributsFils,Attributs).
	\end{lstlisting}
\end{example}

Nous avons maintenant un arbre prêt à être optimisé. Tout d'abord, appliquons les règles les plus classiques dans l'optimisation de requêtes en gestion de base de données : la projection.

\subsection{Projection et sélection}
Cette optimisation permet de réduire l'empreinte mémoire des résultats intermédiaires ce qui de plus réduira les temps de calculs des opérateurs. Pour atteindre ce résultat, il est nécessaire d'appliquer les résultats que nous donne Astral. Ces résultats seront tous présentés dans le chapitre~\ref{chap:validation:expressivite}. Nous pouvons tout de même présenter le prédicat logique qui devra appliquer ces règles.
\begin{regle}[Pousser les projections et sélections]
La transformation d'un nœud contenant la projection afin de l'appliquer sur ses nœuds fils est gérée par le prédicat suivant :
\begin{center} \textbf{pushprojectionrule}($[pi,BPi,[[A,B,C]]],[AOut,BOut,COut]$).\end{center}
De façon similaire, la sélection est gérée par le prédicat :
\begin{center} \textbf{pushselectionrule}($[sigma,BSigma,[[A,B,C]]],[AOut,BOut,COut]$).\end{center}
Ceux deux prédicats s'appliquent de manière itérative.
\end{regle}

Les règles exprimant ces capacités sont en général longues à écrire du fait qu'il est nécessaire de gérer des conditions fines. Pour illustrer ces règles, nous allons montrer des cas simples issus de l'algèbre relationnelle.
\begin{example}
	Tout d'abord, une règle très simple étant le fait de pouvoir transformer $\Pi_A R$ en $R$ si $Attr(R)=A$. Voyons, comment cela s'écrit.
	\begin{lstlisting}
pushprojectionrule(
    [pi, {"attributes": Attr}, [
        [A,B,C]
    ]],
    [A,B,C]
):-
    map_get(B, "attributes", AttrB), %Recupere la liste d'attribut de R
    list_equivalent(Attr,AttrB). %Verifie si les listes sont equivalentes
	\end{lstlisting}
	
	Maintenant, pour la sélection et pour montrer un cas plus complexe. Voyons comment nous pouvons appliquer la règle de l'algèbre relationnelle $\sigma_c (R_1 \cup R_2) = (\sigma_c R_1 \cup \sigma_c R_2)$. Ici, nous n'avons pas de condition à vérifier a priori.
	\begin{lstlisting}
pushselectionrule(
    [sigma, ArgSigma, [
        [union, ArgUnion, [C1,C2]]
    ]],
    [union, ArgUnion, [
        [sigma, ArgSigma, [C1]], 
        [sigma, ArgSigma, [C2]]
    ]]
).
	\end{lstlisting}
\end{example}

\subsection{Autres règles}
Du fait de l'introduction d'autres opérateurs, il peut devenir nécessaire d'introduire d'autres règles d'optimisations. Un des plus efficace serait l'introduction de règles pour appliquer les propriétés de commutativité sur l'opérateur $\D_c^f$. Cet opérateur est en effet très souple puisque tant que nous restons dans le domaine relationnel, il peut commuter à volonté dans cette expression.

Ainsi, le rapprocher au plus prêt des sources permettrait d'éviter de mettre à jour trop souvent les résultats intermédiaires. Pour permettre l'écriture de telles règles complémentaires, nous avons prévu un autre prédicat.
\begin{regle}[Optimisations logiques annexes]
La transformation d'un nœud $[AIn,BIn,CIn]$ en $[AOut,BOut,COut]$ pour l'optimisation est géré par le prédicat :
\begin{center} \textbf{optimizationrule}($[AIn,BIn,CIn],[AOut,BOut,COut]$).\end{center}
Ce prédicat est appliqué de manière itérative \textit{après} l'application des règles de projections et de sélection.
\end{regle}

Contrairement aux règles habituelles des bases de données, nous ne réordonnons pas les jointures du fait du théorème~\ref{thm:asymetrie} et du fait que la notion d'entrée-sortie est réduite à une notion de résultats intermédiaires, même au niveau des sources (donc l'utilisation des index est moins pertinent que sur disque). Toutefois, nous appliquons tout de même la règle permettant de faire des $\theta$-jointures plutôt que des produits cartésiens. En effet, même si nous avions séparé la condition de la jointure, nous pouvons la réunir si nécessaire. Toutefois, si la condition ne concernait qu'une branche, alors la condition se serait propagée plus bas. Avec cet aspect, nous sommes à la limite de l'optimisation physique, que nous allons aborder tout de suite.