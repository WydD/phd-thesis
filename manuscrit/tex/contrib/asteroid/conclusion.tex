\section{Conclusion}\label{sec:contrib:asteroid:conclusion}
Dans ce chapitre, nous avons permis au support persistent relationnel d'être nativement intégré à Astronef grâce au support d'Astral. L'analyse des quatre dynamiques de données nous a permis d'identifier une méthode pour former le schéma physique de la base de donnée. De plus, elles nous indiquent nativement les possibilités d'interrogations.  Astral permet ensuite d'unifier les deux mondes pourtant régis par des dynamiques, des modes d'interrogations et des concepts différents. Cette capacité nous montre une réelle capacité à gérer l'hétérogénéité que nous nous sommes fixés lors de cette thèse.

L'intégration architecturelle du support persistant s'appuie fortement sur les connaissances que nous disposons avec Astral en terme de modélisation des sources de données. Ainsi, nous avons conçus plusieurs composants capables de refléter différentes sémantiques pour les modes de collecte de données, comme en terme de persistance de ces données. Notre moteur de règle développé dans Astronef montre sa flexibilité grâce à cette intégration puisqu'il a été possible de mettre en œuvre des optimisations non-triviale du plan de requête.

Toutefois, notre approche n'est pas entièrement générique. En effet, dans le cadre de la persistance des données du catalogue, des composants spécifiques doivent être mis en place. Nous avons cité les approches issues de la mise à jour de vue. Dans notre cas, des travaux tels que~\cite{Shu:viewupdate} proposent une façon de résoudre ce problème par l'utilisation de solveur de contraintes. L'intégration des contraintes de sémantiques supplémentaires (unicité de l'\textit{IP}, ou du nom d'application par exemple) se traduit dans cette proposition par un simple ajout de contraintes, ce qui semble correspondre à notre application. Plusieurs investigations serait nécessaire de ce côté.

Nous nous sommes basés sur des heuristiques et sur l'application itératives de règles pour résoudre l'optimisation du plan de requête. Une généralisation de l'approche pourrait optimiser des plans plus complexes, notamment dû à l'ordre des jointures. Par exemple, si nous souhaitons optimiser $(R_1 \Join R_2) \Join R_3$ avec $R_2$ et $R_3$ issus d'un même SGBD. Même en supposant qu'en Astral la jointure soit associative (ce que nous démontrons dans le chapitre suivant), nous ne pouvons pas chercher de plan permettant $R_1 \Join (R_2 \Join R_3)$ avec $R_2\Join R_3$ poussé au niveau SGBD. Le domaine des SGBD a rencontré le même problème ce qui a permis l'introduction de la programmation dynamique dans l'optimisation de requêtes. Nous pourrions améliorer nos performances en utilisant un tel procédé.