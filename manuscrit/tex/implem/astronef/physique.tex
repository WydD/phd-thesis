\section{Optimisation physique}\label{sec:contrib:astronef:physique}
Nous supposons maintenant que l'arbre que nous manipulons est optimal d'un point de vue structurel. Les composants opérateurs implémentent une sémantique particulière, notamment suivant leur configuration. Cette sémantique peut-être traduite grâce à Astral. Une fois ces sémantiques établies il est nécessaire de sélectionner les meilleurs composants pour affecter.
\subsection{Macro-blocs}
Afin d'exécuter des sous-parties de la requête de façon plus ad-hoc et optimisés, nous utilisons le concept de macro-blocs. Par exemple, la combinaison agrégation-fenêtre $\G S[W]$ largement étudié dans la littérature est un macro-bloc. Par la suite, des composants seront capables d'exécuter cet opérateur composite. Nous supposons ici l'hypothèse~\ref{hyp:macro} permettant d'appliquer des macro-blocs dès que possible (afin de réduire le nombre de composants).
\begin{hyp}[Heuristique des macros-blocs]\label{hyp:macro}
    Plus le nombre de composants opérateurs utilisés pour exécuter une requête est petit, plus son exécution est efficace.
\end{hyp}

Par la suite, la mise en œuvre de ces blocs se fera via l'utilisation d'un prédicat spécifique pour transformer un arbre ou un sous-arbre en un nouveau. Il est important de voir que la nature du nœud pourra évidemment changer qui pourra ne pas être un opérateur standard de l'algèbre.
\begin{regle}[Regroupement de macro-blocs]
La transformation d'un groupe de nœud $[AIn,BIn,CIn]$ en un macro-bloc $[AOut,BOut,COut]$ est géré par le prédicat :
\begin{center} \textbf{macrogroup}($[AIn,BIn,CIn],[AOut,BOut,COut]$).\end{center}
L'application de ce prédicat est faite de manière itérative.
\end{regle}
\begin{example}
    Reprenons l'opérateur composite agrégation-fenêtre $\G S[W]$. Nous allons donc combiner les deux opérateurs \textbf{aggregate} et \textbf{window} pour former un nouveau nœud \textbf{windowaggregate}. Celui-ci pourra avoir plusieurs implémentation.
    \begin{lstlisting}
macrogroup(
    [aggregate, ArgAgg, [
        [window, ArgWindow, C]
    ]], 
    [windowaggregate, ArgWinAgg, C]
):-
    map_get(ArgWindow, "description", [D]), !,
    map_put(ArgAgg, ["description", [D]], ArgWinAgg).
    \end{lstlisting}
\end{example}
Il est important de noter que si un groupe est créé, il doit exister un composant capable de le traiter tel qu'il a été formé. Ainsi, il est nécessaire de gérer proprement les conditions supplémentaires si les implémentations sont limités. En reprennant notre exemple, si nous ne possèdons qu'un composant capable d'exécuter le nœud \textbf{windowaggregate} uniquement avec une description temporel, alors nous aurons une impossibilité de construction de l'arbre si nous ne raffinons pas les conditions d'applications du prédicat.

\subsubsection{Opérations d'n-uplets}
Les opérateurs d'n-uplets regroupent tous les opérateurs capables de réduire leur opération à un traitement n-uplet par n-uplet.
\begin{defi}[Opérateurs d'n-uplets]\label{def:operateurtuple}
    Soit $TS$ une séquence de n-uplets,

    Un opérateur d'n-uplet $\Lambda$ est défini par la fonction partielle d'n-uplet vers n-uplet : $\lambda$.
    $$\Lambda(TS) = \{\lambda(s) / s \in TS \}$$
    Cet opérateur s'applique naturellement pour les flux ou relations s'il en respecte les contraintes.
\end{defi}

Les exemples de tels opérateurs sont : sélection, projection, renommage et évaluation. Ces opérateurs ont tous pour propriété le fait de pouvoir s'évaluer n-uplet par n-uplet. La particularité des opérateurs est leur composition. La proposition~\ref{prop:composition:operateurtuple} montre que l'évaluation de celle-ci est égal à la composition des traitements n-uplets par n-uplets. Ainsi, il est possible de regrouper tous les opérateurs d'n-uplets en un seul composant efficace. La règle pour appliquer cette opération utilisera le prédicat \textbf{macrogroup}.
\begin{prop}[Composition d'opérateurs d'n-uplets]\label{prop:composition:operateurtuple}
    La composition d'opérateurs d'n-uplet est égale à l'opérateur d'n-uplet définit par la composition de leurs fonctions partielles.
\end{prop}

Afin de simplifier les règles de type, d'implémentation et de macro-bloc, nous créons un prédicat \textbf{unaryimpl}($A$,$B$,$Impl$) permettant de déclarer que le nœud de nature $A$ avec la configuration $B$ peut se traiter n-uplet par n-uplet avec le composant $Impl$\footnote{\textit{Impl} devra implémenter le service \textit{UnaryOperation} qui possède la méthode \textit{Tuple compute(Tuple)}}.

\subsection{Sélection des composants}
Nous en venons désormais à la dernière règle : la sélection du meilleur composants exécuter l'arbre. Nous avons un arbre structuré de manière efficace. Il nous faut trouver la meilleure implémentation pour exécuter au mieux la requête. Ce choix pourra être seulement basé sur la nature du nœud dans le cas où il n'existe pas d'autres alternatives. Mais dans la plupart des cas, il faudra sélectionner selon la configuration.
\begin{regle}[Sélection d'implementations]
La sélection du composant nommé $Impl$ pour le nœud $[A,B,C]$ est décidé par le prédicat :
\begin{center} \textbf{implrules}($[A,B,C]$,$Impl$).\end{center}
L'application de ce prédicat est faite de manière récursive.
\end{regle}
\begin{example}
    Les opérateurs de séquences de fenêtres $[L]$ (dernier n-uplet) et $[B]$ (dernier batch) se définissent avec une description de séquence de fenêtre générique. Toutefois, leur implémentation ne nécessite pas d'utiliser un opérateur générique car elle est très simple au final. Dans l'exemple suivant, nous avons deux composants \textit{LastBatchWindow} et \textit{WindowImpl}. Le premier est capable de former $[L]$ ou $[B]$ et le deuxième est générique.

    Nous utilisons un prédicat capable d'identifier les fenêtres particulières. Si la description correspond à ces fenêtres, alors \textit{LastBatchWindow} sera utilisée, \textit{WindowImpl} sera utilisé par défaut. Ce qui se traduit en prolog par :
\begin{lstlisting}
implrules([window,{description: [D]},_], "LastBatchWindow"):-
    lastbatchorlasttuple(D), !.
implrules([window,_,_], "WindowImpl"):- !.
\end{lstlisting}
\end{example}

\subsection{Calcul incrémental}
Dans la section~\ref{sec:rw:sgfd:optimisation:flux}, nous avons présenté le calcul incrémental et son intérêt dans l'optimisation du traitement des flux. Ce principe reste applicable naturellement dans Astral, il est toujours possible de définir à partir d'une relation temporelle $R$ les deux $\Delta_R^+$ et $\Delta_R^-$. Ces deux objets indiquent les différences de $R$ à chaque \textit{batch} (resp. ajout et suppression). 

Certains composants sont donc capables de traiter une relation en utilisant uniquement ces $\Delta_R$. Et certains opérateurs sont capables de fournir nativement les $\Delta_R$. Ainsi, il devient nécessaire de sélectionner les composants les plus capables d'exploiter ce mode.

Nous introduisons donc une annotation permettant d'indiquer qu'un nœud fournissant une relation temporelle est capable de produire nativement des $\Delta$. Un prédicat \textbf{dynamicoperator}($[A,B,C]$) a donc été construit. Un traitement sera appliqué pour ajouter la propriété \textit{dynamic=1} dans tous les nœuds de l'arbre avant la sélection de composants.
\begin{example}
L'opérateur de séquence de fenêtre supporte nativement le fait de fournir un mode incrémental. Nous pouvons donc écrire la règle suivante :
\begin{lstlisting}
dynamicoperator([window,_,_]).
\end{lstlisting}

Par la suite, le streamer $\IS$ lui est capable de supporter les deux modes. Il est important de noter que le calcul incrémental pour les streamers $\IS$ et $\DS$ est très important car leur coût devient nul. Ces deux modes sont gérés par deux implémentations différentes, ce qui se traduit par :
\begin{lstlisting}
implrules([streamer,B,[C]], "DynamicIs"):-
    map_get(B,'stype','Is'), isdynamic(C), !.
implrules([streamer,B,_], "Is"):- %Par defaut, nous utilisons Is
    map_get(B,'stype','Is'), !.
\end{lstlisting}
\end{example}

Nous avons donc vu comment, par le renseignement de règles logiques, nous pouvons construire un plan de requête efficace. Ce plan est construit par sa restructuration logique et par la sélection des meilleurs composants pour mettre en œuvre cet arbre. Une évolution dans la même ligné que le calcul incrémental serait de raffiner les structures utilisés dans les résultats intermédiaires.

L'arbre fournit par l'application finale de la sélection des composants est ensuite donné à un service capable d'instancier les différents composants qui constituent le plan de requête. Il est intéressant de noter que ce service est lui-même écrit en \textit{PROVA}.
