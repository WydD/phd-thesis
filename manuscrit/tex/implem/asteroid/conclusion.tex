\section{Conclusion}\label{sec:contrib:asteroid:conclusion}
Dans ce chapitre, nous avons permis au support persistant relationnel d'être intégré à Astronef grâce à Astral. L'analyse des quatre dynamiques de données a mis en avant une méthode pour former le schéma physique de la base de données. De plus, elles nous indiquent les possibilités d'interrogation. Astral permet d'unifier les deux mondes pourtant régis par des dynamiques, des modes d'interrogation et des concepts différents. Ainsi, nous arrivons à gérer l'hétérogénéité en terme d'évolution des données que nous nous sommes fixés lors de cette thèse.

L'intégration architecturale du support persistant s'appuie fortement sur les connaissances dont nous disposons avec Astral en terme de modélisation des sources de données. Ainsi, nous avons conçu plusieurs composants capables de refléter différentes sémantiques pour les modes de collecte de données, comme en terme de persistance de ces données. Notre moteur de règles développé dans Astronef montre sa flexibilité grâce à cette intégration puisqu'il a été possible de mettre en œuvre des optimisations non triviales du plan de requête.

Toutefois, notre approche n'est pas entièrement générique. En effet, dans le cadre de la persistance des données du catalogue, des composants spécifiques doivent être mis en place. Nous avons cité les approches issues de la mise à jour de vue. Dans notre cas, des travaux tels que~\cite{Shu:viewupdate} proposent une façon de résoudre ce problème par l'utilisation de solveur de contraintes. L'intégration des contraintes de sémantiques supplémentaires (unicité de l'\textit{IP}, ou du nom d'application par exemple) se traduit dans cette proposition par un simple ajout de contraintes, ce qui semble correspondre à notre application. Plusieurs investigations seraient nécessaires sur cet aspect.

Nous nous sommes basés sur des heuristiques et sur l'application itérative de règles pour résoudre l'optimisation du plan de requête. Une généralisation de l'approche pourrait optimiser des plans plus complexes, notamment dus à l'ordre des jointures. Par exemple, si nous souhaitons optimiser $(R_1 \Join R_2) \Join R_3$ avec $R_2$ et $R_3$ issus d'un même SGBD. Même en sachant qu'en Astral la jointure soit associative, nous ne pouvons pas chercher de plan permettant $R_1 \Join (R_2 \Join R_3)$ avec $R_2\Join R_3$ poussé au niveau SGBD. Le domaine des SGBD a rencontré le même problème ce qui a permis l'introduction de la programmation dynamique dans l'optimisation de requêtes. Nous pourrions améliorer nos performances en utilisant un tel procédé.

Nous avons désormais un système de gestion de données permettant de gérer données persistantes et temps réel. Nous validons notre approche en déployant ce système pour l'observation du réseau domestique.