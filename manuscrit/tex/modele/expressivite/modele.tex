\section{Choix des fondations de l'algèbre}\label{sec:valid:expressivite:modele}
Lors de l'établissement des premières définitions d'Astral dans la section~\ref{sec:contrib:astral:definitions}, nous avons fait des choix concernant le temps, les entités et les équivalences de requêtes. Cette section discute de la validité de ces choix en montrant que des choix différents auraient menés à des ambiguïtés sémantiques. La section~\ref{sec:valid:expressivite:modele:temps} présente le choix de continuité du temps. La section~\ref{sec:valid:expressivite:modele:coherence} détaille l'hypothèse de cohérence temporelle. Enfin, nous analysons nos choix en terme de gestion des ordres dans la section~\ref{sec:valid:expressivite:modele:ordres}.

\subsection{Continuité du temps}\label{sec:valid:expressivite:modele:temps}
La définition~\ref{def:timestamp} présente un \textit{timestamp} comme un élément d'un espace continu. Dans la littérature, le temps est souvent considéré comme un entier, ou au mieux dans un espace isomorphe à $\N$. Notre choix permet de mieux gérer les différences d'interprétation du temps.

En effet, chaque système informatique est limité par un \textit{chronon} : la plus petite différence de timestamp observable. Pour certains système, ce \textit{chronon} est d'une milliseconde, d'autres d'une seconde et d'autres d'un \textit{tick} processeur. Ne pas se restreindre à un \textit{chronon} particulier permet de manipuler facilement les \textit{timestamps} issus de deux systèmes de datation (synchronisés) sans ambiguïté. De façon plus formelle, nous aurions pu définir le temps comme un ensemble isomorphe à $\N$. Dans un tel cas, l'utilisation d'opérateurs binaires serait plus délicate. En effet, il y aurait deux notions de temps pour chacune des branches. Ainsi, il faudrait introduire des outils pour intégrer ces deux horloges en une commune.

Par mesure de simplicité, nous avons fait le choix d'avoir un seul temps universel. Dans la pratique, cela veut dire que les \textit{timestamps} sont synchronisés au niveau des différents équipements distribués, ou que les \textit{timestamps} sont issus du système où est évalué la requête. Ceci est un domaine de recherche complexe à part entière que nous ne détaillons pas dans cette thèse. En supposant une horloge commune, alors le choix d'avoir un \textit{timestamp} réel nous permet d'établir une précision indépendante du \textit{chronon}.

Nous remarquons aussi que ce choix permet de clarifier l'opérateur $\mathcal{RS}$ de STREAM~\cite{Arasu:stream}. Cet opérateur est décrit par la phrase \enquote{\it à chaque timestamp, envoyer l'ensemble de la relation}. Cet opérateur est dépendant du système car si un système possède un chronon de $1s$ alors $\mathcal{RS}$ produit des n-uplets chaque seconde. Pour un autre système possédant un chronon de $1ms$ alors le streamer produit plus d'n-uplets. Cet opérateur est remplacé par $\RS{r}$ dans Astral avec $r$ une période de temps explicite.

\subsection{Hypothèse de la cohérence temporelle}\label{sec:valid:expressivite:modele:coherence}
L'hypothèse de la cohérence temporelle~\ref{hyp:ordres} affirme que les n-uplets doivent arriver dans un flux de manière ordonnée selon leurs \textit{timestamps}. Cette hypothèse a suscité beaucoup d'interrogation de la part de la communauté. La question est de savoir s'il est nécessaire que d'autres opérateurs existent dans l'algèbre pour garantir cette propriété, ou est-ce à l'implémentation de le garantir d'une manière ou d'une autre ? Par exemple, Aurora~\cite{Abadi:aurora} définit des opérateurs spécifiques au tri d'un flux grâce à une mémoire tampon de $n$ n-uplets.

Dans Astral, si l'hypothèse n'est pas vérifiée, nous avons la fonction position-\textit{batch} (def~\ref{def:tau}) qui n'est plus croissante. Ainsi, sa pseudo-inverse n'existe plus, ce qui fait qu'il devient impossible de définir les séquences de fenêtres telles que nous les avons faites. Par exemple, pour les fenêtres positionnelles contenant les 50 derniers n-uplets, la notion de \textit{dernier} est sémantiquement lié aussi à son \textit{timestamp} ce qui induit des confusions. D'un point de vue implémentation, la croissance du temps fait qu'une fois qu'un \textit{timestamp} $t$ est traité, il est nécessaire de garantir que toutes les données inférieures à $t$ ont été traités. Ainsi le \textit{scheduler} peut décider d'exécuter un opérateur en garantissant la sémantique d'Astral.

Notre constat est le suivant : pour avoir une algèbre sans ambiguïté sémantique, nous devons supposer que les \textit{timestamps} sont croissants. C'est à l'implémentation de garantir cette contrainte, et si elle n'est pas vérifiée, il est très difficile de prévoir les conséquences.

\subsection{Sémantiques d'ordres}\label{sec:valid:expressivite:modele:ordres}
L'évaluation d'une relation temporelle à un \textit{batch} donné n'est pas un ensemble d'n-uplet, c'est une séquence d'n-uplet. Ce choix est central car il intervient dans la majorité des définitions. Que ce soit dans la définition du produit cartésien~\ref{def:produit} ou des \textit{streamers}~\ref{def:streamers}, où la sémantique que nous choisissons pour l'ordre des n-uplets est explicitée.

Dans la littérature, les flux sont souvent étendus du modèle $\mathcal{SEQ}$~\cite{Seshadri:seq} décrivant les manipulations de séquences. Il est acquis que les flux sont des ensembles totalement et strictement ordonnés. Or, lorsque nous transformons ce flux en relation temporelle, cet ordre est rarement étudié. Pourtant, nous avons vu dans la définition des \textit{streamers}~\ref{def:streamers} qu'il est nécessaire assigner un ordre strict aux flux produits. 

Dans Astral, nous considérons que les relations instantanées doivent avoir un ordre pour obtenir un flux correctement ordonné après l'application d'un \textit{streamer}. Ainsi, nous n'avons pas d'ambiguïté sémantique lié à cet aspect. Cette formalisation plus stricte nous a amené à découvrir le théorème~\ref{thm:asymetrie} qui montre l'asymétrie du produit cartésien sur les relations temporelles.

Il est important de noter que ce théorème est vrai à cause du choix de l'équivalence de requête (def~\ref{def:equivalence}). Cette équivalence inclue deux notions, celle des entités initialisé qui prend tout son sens dans le cadre des transpositions, et celle des inclusions et équivalences de séquences. Nous avons en effet définit l'inclusion des relations instantanées comme une définition d'inclusion de suite, ce qui nécessite une équivalence de l'ordre. Une définition différente de l'équivalence de requête permettrait d'obtenir une symétrie du produit. Dans la pratique, il est en effet possible que l'utilisateur souhaite obtenir ses n-uplets dans un ordre quelconque, ce qui pourrait permettre des optimisations supplémentaires.

Ces choix pour les définitions fondamentales de l'algèbre permettent d'avoir une sémantique claire et sans ambiguïté. Nous présentons maintenant l'expressivité d'Astral vis à vis d'algèbres existantes.